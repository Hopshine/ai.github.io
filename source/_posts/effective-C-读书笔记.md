---
title: effective C++读书笔记
date: 2017-05-27 12:26:01
tags: C++, note
---

### 1.将C++看成是一个集合
C++可以看成是以下四个部分的集合：
- c
- c 面向对象
- 模板
- STL编程

### 2. 尽量以const、inline、enum来代替define
- 主要的目的是以编译系统的检查来防止某些错误
- define的作用域是全局的，而const等则可以避免这些污染
- 以const和enum来替换define来定义常量
- 以inline来替换define来替换函数


### 3.尽可能多的使用const
- 可以避免很多无意识的修改，特别是提供库给其他人使用的时候
- 可以快速的定位问题，方便调试
- const在*左边，表示指向的变量是常量，防止则是指针不能再定向，形如：

```C++

int const * p // p指向的这个值不能变
int * const p // p不能再指向其他的变量

```

- const使用在成员函数和重载运算符时，可以加快效率，防止一些错误
- 使用mutable来修饰成员变量，这样const成员函数就也可以修改它的值


### 4.确保对象使用前已经初始化
- 对默认类型的变量也要注意初始化，否则会出现未定义的情况
- 使用参数初始化列表来代替构造函数中的赋值
- 构造函数中使用的是赋值而不是初始化，在某些场景下，赋值的代价会非常大
- 使用单例模式来替换向外提供的全局变量，注意多线程

### 5.编译器自动做的函数
- 如果什么都没有写，系统会提供以下是个函数：
  - 默认构造函数
  - 默认拷贝函数
  - 默认赋值拷贝函数
  - 默认析构函数（==注意是个非虚函数==）
- 如果声明了构造函数，那么系统不会生成不带参数的默认构造函数
- 当成员变量中出现了赋值上的矛盾或未定义行为时，编译器将不会生成默认拷贝函数


### 6.组织编译器自动生成不应该有的函数 
有些情况下，一个类不应该被拷贝，这个时候应该禁止出现拷贝构造函数。但是如果我们不声明拷贝构造函数，那么编译器就会自己生成，对于这种情况，可行的策略是：
- 声明构造函数并将其设置为private
- 更好的做法是声明一个基类，基类中的对应函数声明为private，并只声明不实现

### 7.析构函数virtual化
- virtual函数会带来额外的内存负担，因为要维护一个虚表
- 作为基类的类虚构函数必须用virtual，否则通过基类去析构派生类时会发生严重的内存泄露问题
- string类和STL类都不应该被继承，因为他们的析构函数都非虚

### 8.析构函数不应该抛出异常
- 一个类很可能出现在一个数组中，如果当中某个发生了crash，那么剩余的可能都会抛出异常，多个异常抛出的时候，其处理行为是未定义的。解决的方式是：
  - 将异常catch捕获
  - 直接终止std::abort()
  - 额外提供一个函数，而不是使用析构函数去完成这个动作，思路是：
    - 提供一个管理类
    - 提供一个抛出异常的函数，让调用者去处理这个异常

### 9.不在构造和析构函数中去调用虚函数
- 当一个类作为基类时，在构造函数中去调用一个虚函数，会导致其子类构造时调用错误的函数。因为构造的顺序是先基类后子类，在初始化没有完成之前，调用到的会是基类的那一个。
- 解决的方案：不使用虚函数，而使用一个非虚的函数加上参数去识别

### 10.重载 = 运算符时，应该返回*this
好处：可以实现连锁复制

### 11. 防止 = 出现只我赋值
在重载 = 时，应该做判断

```  C++

A& A::opeartion=(const A& another) {
    if(this == &another) // if same, return
    {
        return *this;
    }
}

```
### 12. 复制函数时应该赋值每一个部分
尤其注意，覆写子类的拷贝构造函数时，应该调用父类的构造函数

---

### 13.用对象来管理资源
- 不应该企图用函数的调用流程来保证资源一定会释放，而是是用一个对象，在对象的析构函数中释放资源
- 可以考虑使用只能指针来避免这个问题，但是仍有危险
- 智能指针不允许多个引用同时指向一个量，复制会让前面一个值为null
- 引用计数智能指针可以部分解决这个问题，采用的是计数方式，当然也存在循环引用的问题
- 注意，一般的智能指针的析构函数的实现都是 delete *p，而不会delete *p[]，这意味着，将智能指针用在数组中并不合适


### 14. 注意资源管理类中的复制行为
- 有的资源是独占式的（比如说同步锁），在这种情况下，应该机制其拷贝函数。
- 对于需要拷贝资源的情况，可以考虑使用计数方式管理

### 15. 资源管理类中应当提供对原始资源的访问
比如：

```
class FontManager {
    private:
        Font font;
    ...
    
    public:
        Font getFont() 
        {
            return font;
        }
}
```
记住一个原则就是，资源管理类是为了减少资源的泄露和使用的难度，故而设计原则应该是：隐藏被调用者不需要看到的东西，但是应该完备的提供可能会用到的东西

### 16. new 和 delete应该成对的使用。具体来说，new如果是new的数组，delete时候也应该是数组，反之亦然

### 17. 使用智能指针时，将new出的对象放入智能指针中应该单独写一个语句
反面教材是这样的：
```
process(auto_ptr<DemoC> p(new DemoC(), generateParameter())
```
---
### 18. 尽量让接口正确使用
- 对输入的参数进行强制类型的规定，必要的时候引入enum，自定义结构体，做参数检查等
- 保持与一般的使用情形相一致
- 注意结构的一致性，同一类接口不应该用不同的方法去实现，比如求取一个容器类的大小，可以是

```
list.size
list.size()
list.count
list.count()
list.length
list.length()
```
诸如这样的接口基本上都能看到，但是在同一份代码中，应该尽量统一，以免造成混乱。
- 可以想办法限制用户的操作，比如将返回的值放入智能指针中

### 19. 定义一个类应该注意哪些方面
- 如何被创建和销毁
- 初始化和赋值的区别
- 如果以值传递后果是什么
- 考虑类的约束条件
- 考虑继承的问题
- 考虑类的类型转换问题（包括隐私转换和其他类的转换）

### 20. 以const引用来代替值传递
- 可以节省大量的时间，因为值传递意味着构造函数和函数调用完后的析构函数的调用，也包括其中的内部类对象
- 可以防止类型切割的问题，所谓的类型切割，形如：

```
class A {
    private:
    demo();
};

class B : public A {
  demo();  
};

void process(A a) {
    a.demo();
}

B b = B()
process(b)  //最终会调用基类的demo函数
```

- 一般来说，内置对象和stl对象可以用值传递，其他的建议使用const引用传递

### 21.不要在类的内部方法中返回一个引用
- 很有可能造成一个空的引用
- 也不能试图用静态变量，这样会造成同一种类型的对象运算时出错
- 与20条对应，用引用代替值传递这种事情应该在调用端去实现，而不是在实现者中实现

### 22.将类成员变量设置成private
- 参照18条，保持接口的一致性
- 面向接口编程而不是实现编程，这样的好处是在实现更改时，可以保证对外的一致性
- protectd并不比public的封装性好

### 23. 若功能可以在类外部通过已有的接口实现，就没有必要把它放在类内部实现
好处有两个：
1. 可以增加类的灵活性，可扩展性
2. 有助于减少依赖

### 24. 若所有参数都需要类型转换，那么应该使用外部函数

### 25. 关于swap函数
- 如果系统系统的swap（std::swap()）函数效率可以接受，调用即可
- 如果效率不行，可以考虑提供一个对外的swap接口

---
### 26. 尽可能晚的定义变量
- 要用到的时候再定义（直到能给出实参为止）
- 尽可能跳过无意义的默认构造函数，在初始化的时候直接用参数列表的方式初始化
- 对于要使用变量放入循环中赋值时，需要考虑成本

### 27. 尽量少的转型
- 旧式的转型应该少用
- 提供了四类新式转换
  - const_cast: 将const变为非const
  - dymatic_cast：向下安全转型，但是可能耗费大量运行成本
  - reincept_cast：向低级转换，很少见
  - static_cast：强制隐式转换
- 总的原则是，能不用转换就不用

### 28. 避免返回的handle指向内部
- 其实和21相同，这一条可以略过
- 记住如果一定要返回reference，记得带上const

### 29. 关于异常
- 需要在设计函数的时候将异常的情况考虑在内
- 处理异常可以分成三个等级：
  - 基本保证。即异常情况发生之后，程序仍然会正常运行，不会扰乱控制流
  - 强烈保证，类似于用先复制后删除来代替剪切。当程序发生异常时，可以回到执行之前的状态
  - 不抛出承诺

### 30. 关于内联函数
- inline函数会造成程序的体积变大
- inline函数由于展开的特性，其调试会非常困难，因为不可能在一个不存在的地方打断点
- inline只是一个编译优化的建议而非编译器一定会采取的行为
- inline函数会在函数实现发生更改时，造成所有引用它的模块都必须重新编译

### 31. 降低文件间的依赖关系
对于一个常见的类：

```
class A {
    public:
    A (DataA d1, DataB d2, DataC d3)
    private:
        DataA a;
        DataB b;
        DataC c;
    
}
```
以上的代码会让classA依赖于DataA，DataB和DataC的实现，无心当中就造成了相当严重的依赖。而这些依赖在编译期间是必须使用的，因为要确定每个变量所占空间的大小。为了解决这种困境，可以使用的方法就是，使用指针而不使用具体的对象。因为对象的大小是可以确定的，只要来一个前置声明即可，i.e.,

```
class A {
    public:
    A (DataA *d1, DataB *d2, DataC *d3)
    private:
        DataA *a;
        DataB *b;
        DataC *c;
```

---

### 32. 公有继承只能刻画is-a的关系
道理很简单，但是要考虑清楚一点，有些事情会反直觉

### 33. 避免覆盖基类的声明
- 在共有集成时，不要使用和基类一模一样的非虚函数名称
- 如果基类中有你不想要继承而是想覆写的方法，说明is-a的关系是有问题的

### 34. 区分接口继承和实现继承
- 纯虚函数意味着继承接口，子类必须要将接口实现
- 非纯虚函数意味着提供一个缺省的实现，如此一来，子类中就有一个默认的实现
- 非虚函数意味着，所有子类的行为应该一致，不允许发挥
- 应该考虑将默认行为函数和接口分离，以免造成后来维护的人的误解

### 35. nvi手法
可以将一些共性提取出来，放在基类函数的非纯虚函数中，得到一个默认实现。而在这个默认的实现中，调用纯虚函数，这个纯虚函数要求子类去实现。在实现的手法上，破有一种java的interface回调的意味。

### 36. 不要重载一个非虚函数

### 37. 不要更改继承而来的方法的默认值
- 覆写了默认值之后，会造成不同的方式调用子类方法，具体的实现不一致
- 将子类和基类的默认值保持一致可以保证行为一致，但是有两个问题：
  1. 代码重复
  2. 当基类的默认值发生改变时，所有的子类的默认值都需要更改
解决以上问题的方案是使用nvi的手法，使用一个非虚函数去调用这个虚函数，在调用的过程中赋予一个默认值。这样就两全其美了。

### 38. 能使用组合完成任务的时候不要使用继承

### 39. 谨慎的使用私有继承
- 私有继承在大部分情况下可以使用符合去完成
- 在面对两个类而又要覆写当中多个虚函数的时候，私有继承是可以考虑的
- 从层次上来说，私有继承不处于设计的层次上，而处于实现的层次上。


### 40. 谨慎的使用多重继承
- 多重继承一般能不用就不用
- 为了避免菱形继承的出现，应该使用虚继承，否则会出现祖先基类的两份拷贝。但是应该注意，不应该在没有确实必要的情况下使用虚继承，因为这样回造成大量的损耗

---

### 41. template其实就是一种编译器多态
- 并不需要在实例化之后才能确定类型
- 需要实现规定好接口

### 42. 声明template参数时，class和typename是等价的

### 43. 当template的具体类型是子类
当tempalte中的集体类型是一个子类，而这个子类去试图调用基类的方法时，会发生编译错误。原因很简单，41中说明，template是编译期的多态，因此在编译时就要确认到底是那种类型。解决的方案：
- 加上this
- 使用using，或者直接加上作用域限定符

### 44. 避免由于template导致编译出的代码膨胀
应该剥离出不变的部分，而将相同的部分放入template中

~~==关于template编程和stl编程少有接触，略去==~~
### 45. 略

### 46. 略

### 47. 略

### 48. 略


---

### 49. 可以使用set_new_handler来定制化new出现异常时的处理函数
- 这种定制可以在new之前调用，在调用完毕之后set为null
- 可以在类的内部指定一个new的handler

### 50. 可以自定义new和delete
- 编译器自带的new和delete往往并不是最适合的
- 可以通过覆写new和delete的提高性能
- 可以提供错误调试信息，给出统计等

### 51. 略去

### 52. 略去

---

### 53. 重视编译器的警告信息

### 54. 熟悉STL

### 55. 熟悉Boost
